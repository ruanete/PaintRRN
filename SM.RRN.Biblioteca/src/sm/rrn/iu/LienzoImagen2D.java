/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sm.rrn.iu;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.image.BufferedImage;
import sm.rrn.graficos.RectanguloRRN;
import sm.rrn.graficos.RellenoRRN;
import sm.rrn.graficos.ShapeRRN;
import sm.rrn.graficos.TrazoRRN;

/**
 * Clase que define un lienzo el cual estará compuesto por una imagen y en el cual se podrán dibujar formas con sus respectivos atributos.
 * @author Raúl Ruano Narváez
 */
public class LienzoImagen2D extends Lienzo2D {
    BufferedImage imagen;
    Boolean imagenAbierta;

    /**
     * Booleano que especifica si activar el contorno de una figura en edición o no
     */
    public static Boolean activarBound;
    
    /**
     * Constructor por defecto de LienzoImagen2D
     */
    public LienzoImagen2D() {
        initComponents();
        imagen = null;
        imagenAbierta = false;
        activarBound = true;
    }
    
    /**
     * Método que setea una imagen en el lienzo
     * @param imagen BufferedImage con la imagen que se va a setear
     */
    public void setImage(BufferedImage imagen){
        this.imagen = imagen;
        if(imagen!=null) {
            imagenAbierta = true;
            setPreferredSize(new Dimension(imagen.getWidth(),imagen.getHeight()));
        } 
    }
    
    /**
     * Método que devuelve la imagen actual que hay en el lienzo
     * @param guardar Booleano para decidir si devolver la imagen para guardar o no
     * @return Devuelve un BufferedImage con la imagen del lienzo
     */
    public BufferedImage getImage(boolean guardar){
        if(guardar){
            BufferedImage imageFinal = new BufferedImage(imagen.getWidth(), imagen.getHeight(), imagen.getType());
            activarBound=false;
            paint(imageFinal.createGraphics());
            activarBound=true;
            return imageFinal;
        }
        return imagen;
    }

    /**
     * Método que devuelve si existe imagen abierta en el lienzo o no
     * @return Booleano con valor true o false si la imagen esta o no abierta
     */
    public Boolean getImagenAbierta() {
        return imagenAbierta;
    }

    /**
     * Método para setear una imagen en un lienzo
     * @param imagenAbierta Boolean con true o false en función de si la imagen se va abrir o no
     */
    public void setImagenAbierta(Boolean imagenAbierta) {
        this.imagenAbierta = imagenAbierta;
    }

    /**
     * Método para activar el contorno que rodea toda la imagen
     * @return Boolean con true o false
     */
    public Boolean getActivarBound() {
        return activarBound;
    }

    /**
     * Método para activar o no el contorno que rodea la imagen
     * @param activarBound Booleano con true o false
     */
    public void setActivarBound(Boolean activarBound) {
        LienzoImagen2D.activarBound = activarBound;
    }
    
    @Override
    public void paintComponent(Graphics g){
        super.paintComponent(g);
        
        if(this.imagen!=null) 
            g.drawImage(this.imagen,0,0,this);
        
        dibujarLienzo(g);
    }
    
    /**
     * Método que va a dibujar el lienzo en, activando o no el contorno de la imagen y pintando un cuadro blanco si no hay imagen abierta o pintando la imagen si esta abierta
     * @param g Graphics para poder pintar en el lienzo
     */
    public void dibujarLienzo(Graphics g){
        ShapeRRN shape = new RectanguloRRN(new Point(0,0), imagen.getWidth(), imagen.getHeight());
        Graphics2D g2d = (Graphics2D)g;
                
        if(!imagenAbierta){
            shape.añadirAtributo(new RellenoRRN(shape, true, Color.WHITE));
        }
        
        if(activarBound){
            shape.añadirAtributo(new TrazoRRN(shape, Color.BLACK, TipoTrazo.LINEA_DISCONTINUA, 1)); 
        }
        
        shape.drawShape(g2d, ModoPintado.Rectangulo, null);  
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(210, 210, 210));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
